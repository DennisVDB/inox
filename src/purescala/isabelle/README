09.05.2011:

- Things we discussed:
  - use matchToIfThenElse to handle pattern-matching with guards - CHECKED but with unexpected behaviour :
   	-- match to If not working for 
				size of BSTSimpler.scala (lexicographic termination order not found)
				isBST  - scripting does not finish ; if I add | _ => False to translation of instanceOf then it gives an error : _ => False is redundant
		--  the following has no lexicographic termination order
		def size(t : Tree) : Int = (t match {
		    case Leaf() => 1
		    case tt @ Node(l,_,r) => size(tt.left) + 1 + size(tt.right)
		  }) ensuring(_ >= 1)
  
  - use SimplePatternMatching extractor to handle "simple" pattern-matching to
    avoid case expressions when it's at the top-level  - CHECKED
  - compute strongly-connected components for function graphs and recursive
    data-types - CHECKED using Kosaraju's algorithm for strongly connected components 
  - topological sorting on Connected components - CHECKED
      -- problems : MutuallyRecursive.thy - could not find termination order
  - try to run Nitpick on lemmas with bugs. - tried but nothing useful deduced
  - deal with functions with duplicate names - CHECKED (each function has its number of arguments attached)

	- for the above 2 problems you can refer to files : testcases/MutuallyRecursive.scala and testcases/ConnectedTest.scala
--------------------------------------------------

Ganea Octavian

- translation from LEON to Isabelle

- does NOT work:
	
	1) proofs of the lemmas : it just tries induction on the first argument (if it has one) and then auto
	2) some obscure operations on sets: multisets, min , max 
	3) if on a case branch of a match: for example :
			TriplePair(isBST0(l), isBST0(r)) match {
	      case TriplePair(Triple(None(),t1,None()),Triple(None(),t2,None()))  if(t1 && t2) => Triple(Some(v),true,Some(v))
				case _ => true
			}
		- translation done well, but isabelle refuses to cooperate 
			
- what works : everything else : 
		1) keywords of the variables names
		2) mutually recursive datatypes 
		3) binders in match cases
		4) field selector
		5) constant functions (arrity 0)
		6) preconditions and postconditions translated as lemmas
		7) usage of sets and other predefined datatypes
		8) mutally recursive functions sorted topological by their strongly connected components
		9) duplicate function names		
		10)instanceOf

		
		
		