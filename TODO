TODO: 
-----

Important: Fix reasons for unsoundness
--------------------------------------

a) eval* will use an empty set instead of an arbitrary which may result in unsoundness 
   if the specs involve function over states
	- fix: make the state argument a free variable (by possibly calling an uninterpreted function with zero arguments)

b) the assertion on the newC function that the new closure is unevaluated may result in unsoundness
	- fix: create new identifiers at the time of creating functions. We can also try and use epsilons.

c) Coinductive (or normal) data-types can help ensure acyclicity of stream but that means we need to create 
   free variables at the time of creation
	currently, we are creating axioms that state acyclicity.

Benchmarks to think about
--------------------------

1. Lazy constraint solving 	
	We can get demand driven pointer-analysis. Can we prove its running time ?

2. Packrat parsers uses memoization
	Can we prove its running time ?

3. ConcTrees full version ?

4. Binomial heaps ?

5. Futures: How about redex algorithms or map-reduce algorithms ?

Things to implement:
----------------------

a) A way to check monotonicity of preconditions
b) Use monotonicity while checking proofs
c) Automatically synthesize the invariant that the state is preserved
d) We can always assume that state is monotonic which proving the specs
c) Extensions for futures 
d) Extensions for memoization
e) Extending Orb for type parameters

Integration

Try to fix bugs in CVC4 proof and also try to integerate it with the system
Try to integrate the tool with Orb

Some Notes
----------

a) It is very essential to make the separation between value and state component explicit
	we can use something like: "foo(x, uiState())" and "foo(x, st)" where st is the actual input state.

b) We need to treat Lazyarg's as not closures. That is, they don't change state and are not considered as Unevaluated. They
	are never added to the set. 
	We can have an implicit type conversion from normal values to lazyargs. 
	Since normal values are eagerly computed. This lets us specify lazyargs succinctly in the code.
	We need to change isEvaluated and value function call modelling

c) Futures when modelled as closures can be stored and then later joined. 
e.g. a function  'spawn' that will spawn tasks and a function 'join' that will join 
the spawned threads.
However, we need to explicitly mark the functions that can be executed in parallel from the 
point of creation of a Future to the point of joining the Future.
Eg. as 
spawn()
spawn()
parallel(op(), join(), join())
//this means op() and the two futures will execute in parallel.


