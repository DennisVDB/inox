testcases/ListWithSize.scala

verifies: associativity of append, size

size                      match.      (11,34) valid               Z3        0.383
size                      postcond.           valid               Z3        0.036
sizeTailRec               precond.    (16,40) valid               Z3        0.003
sizeTailRecAcc            precond.    (21,36) valid               Z3        0.005
sizeTailRecAcc            match.       (19,8) valid               Z3        0.003
sizeTailRecAcc            postcond.           valid               Z3        0.026
sizesAreEquiv             postcond.           valid               Z3        0.010
content                   match.      (30,41) valid               Z3        0.004
sizeAndContent            postcond.           valid               Z3        0.009
drunk                     match.      (39,37) valid               Z3        0.002
drunk                     postcond.           valid               Z3        0.671
funnyCons                 match.      (45,48) valid               Z3        0.007
funnyCons                 postcond.           valid               Z3        0.263
reverse                   postcond.           valid               Z3        0.010
reverse0                  match.      (52,51) valid               Z3        0.002
reverse0                  postcond.           valid               Z3        0.023
append                    match.      (57,51) valid               Z3        0.002
append                    match.      (80,51) valid               Z3        0.004
append                    postcond.           valid               Z3        0.050
nilAppend                 postcond.           valid    induction  Z3        0.003
nilAppend                 postcond.           valid    induction  Z3        0.003
appendFold                postcond.           valid               Z3        0.006
appendAssoc               postcond.           valid    induction  Z3        0.005
appendAssoc               postcond.           valid    induction  Z3        0.007
sizeAppend                postcond.           valid    induction  Z3        0.006
sizeAppend                postcond.           valid    induction  Z3        0.012
concat                    postcond.           valid    induction  Z3        0.010
concat                    postcond.           valid    induction  Z3        0.012
concat0                   match.      (84,60) valid    induction  Z3        0.002
concat0                   match.      (85,24) valid    induction  Z3        0.002
concat0                   postcond.           valid    induction  Z3        0.054
concat0                   postcond.           valid    induction  Z3        0.085

  /* Appending a list 'l' to an empty list yields 'l' */
  @induct
  def nilAppend(l : List) : Boolean = (append(l, Nil()) == l) holds

* /* append is associative */
* @induct
* def appendAssoc(xs : List, ys : List, zs : List) : Boolean =
*   (append(append(xs, ys), zs) == append(xs, append(ys, zs))) holds

* /* The size of the result of appending two lists is the sum of the sizes of
*  * the lists */
* @induct
* def sizeAppend(l1 : List, l2 : List) : Boolean =
*  (size(append(l1, l2)) == size(l1) + size(l2)) holds

  def size(l: List) : Int = (l match {
      case Nil() => 0
      case Cons(_, t) => 1 + size(t)
  }) ensuring(_ >= 0)

  def sizeTailRec(l: List) : Int = sizeTailRecAcc(l, 0)
  def sizeTailRecAcc(l: List, acc: Int) : Int = {
   require(acc >= 0)
   l match {
     case Nil() => acc
     case Cons(_, xs) => sizeTailRecAcc(xs, acc+1)
   }
  } ensuring(res => res == size(l) + acc)

* /* The two size functions are equivalent */
* def sizesAreEquiv(l: List) : Boolean = {
*   size(l) == sizeTailRec(l)
* } holds

==============================

AssociativeList.scala

verifies: read-over-write, key set

domain                    match.      (17,37) valid               Z3        0.258
find                      match.      (22,41) valid               Z3        0.003
noDuplicates              match.      (27,42) valid               Z3        0.003
update                    match.      (32,46) valid               Z3        0.003
update                    postcond.           valid               Z3        0.083
updateElem                match.      (37,58) valid               Z3        0.006
updateElem                match.      (39,44) valid               Z3        0.005
updateElem                postcond.           valid               Z3        0.132
readOverWrite             match.      (47,75) valid    induction  Z3        0.005
readOverWrite             postcond.           valid    induction  Z3        0.040
readOverWrite             postcond.           valid    induction  Z3        0.022

  /* Updating list 'l1' with all mappings from list 'l2' yields a list with the
   * union of key sets */
  def update(l1: List, l2: List): List = (l2 match {
    case Nil() => l1
    case Cons(x, xs) => update(updateElem(l1, x), xs)
  }) ensuring(domain(_) == domain(l1) ++ domain(l2))

  /* Updating list 'l' with mapping 'e' yields a list with the expected key set */
  def updateElem(l: List, e: KeyValuePairAbs): List = (l match {
    case Nil() => Cons(e, Nil())
    case Cons(KeyValuePair(k, v), xs) => e match {
      case KeyValuePair(ek, ev) => if (ek == k) updateElem(xs, e) else Cons(KeyValuePair(k, v), updateElem(xs, e))
    }
  }) ensuring(res => e match {
    case KeyValuePair(k, v) => domain(res) == domain(l) ++ Set[Int](k)
  })

* /* Finding with a key that has been updated gives the most recently updated value */
* @induct
* def readOverWrite(l: List, e: KeyValuePairAbs, k: Int) : Boolean = (e match {
*   case KeyValuePair(key, value) =>
*     find(updateElem(l, e), k) == (if (k == key) Some(value) else find(l, k))
* }) holds

==============================

InsertionSort.scala

verifies: content, size, sortedness

size                      match.      (14,33) valid               Z3        0.294
size                      postcond.           valid               Z3        0.030
contents                  match.      (19,39) valid               Z3        0.002
min                       match.      (24,34) valid               Z3        0.002
min                       match.      (26,33) valid               Z3        0.003
minProp0                  match.      (32,41) valid               Z3        0.002
minProp0                  match.      (34,36) valid               Z3        0.003
minProp0                  postcond.           valid               Z3        0.009
minProp1                  match.       (42,7) valid               Z3        0.004
minProp1                  match.      (44,38) valid               Z3        0.004
minProp1                  postcond.           valid               Z3        0.330
isSorted                  match.      (51,38) valid               Z3        0.005
sortedIns                 precond.    (61,54) valid               Z3        0.012
sortedIns                 match.       (59,7) valid               Z3        0.004
sortedIns                 postcond.           valid               Z3        0.147
sort                      precond.    (70,33) valid               Z3        0.010
sort                      match.      (68,32) valid               Z3        0.002
sort                      postcond.           valid               Z3        0.038

  /* Inserting element 'e' into a sorted list 'l' produces a sorted list with
   * the expected content and size */
  def sortedIns(e: Int, l: List): List = {
    require(isSorted(l))
    l match {
      case Nil() => Cons(e,Nil())
      case Cons(x,xs) => if (x <= e) Cons(x,sortedIns(e, xs)) else Cons(e, l)
    } 
  } ensuring(res => contents(res) == contents(l) ++ Set(e) 
                    && isSorted(res)
                    && size(res) == size(l) + 1
            )

  /* Insertion sort yields a sorted list of same size and content as the input
   * list */
  def sort(l: List): List = (l match {
    case Nil() => Nil()
    case Cons(x,xs) => sortedIns(x, sort(xs))
  }) ensuring(res => contents(res) == contents(l) 
                     && isSorted(res)
                     && size(res) == size(l)
             )

==============================

RedBlackTree.scala

verifies: content, "red nodes have black children"

content                   match.      (13,39) valid               Z3        0.269
size                      match.      (18,31) valid               Z3        0.002
redNodesHaveBlackChildren match.      (30,56) valid               Z3        0.002
redDescHaveBlackChildren  match.      (36,55) valid               Z3        0.002
ins                       precond.    (46,33) valid               Z3        0.539
ins                       precond.    (46,40) valid               Z3        0.010
ins                       precond.    (48,33) valid               Z3        0.338
ins                       precond.    (48,43) valid               Z3        0.007
ins                       match.       (43,7) valid               Z3        0.002
ins                       postcond.           valid               Z3        1.801
makeBlack                 postcond.           valid               Z3        0.035
add                       precond.    (65,14) valid               Z3        0.014
add                       precond.    (65,18) valid               Z3        0.003
add                       postcond.           valid               Z3        0.029
balance                   match.      (94,19) valid               Z3        0.028
balance                   postcond.           valid               Z3        0.999

w/o balance conditions
ins                       precond.    (46,40) valid               Z3        0.029
ins                       precond.    (48,43) valid               Z3        0.012
ins                       match.       (43,7) valid               Z3        0.005
ins                       postcond.           valid               Z3      100.981


  /* Adding value 'x' to tree 't' in which no red node has a red child produces
   * a tree which conserves the same property and has the expected content */
  def add(x: Int, t: Tree): Tree = {
    require(redNodesHaveBlackChildren(t))
    makeBlack(ins(x, t))
  } ensuring (res => content(res) == content(t) ++ Set(x) && redNodesHaveBlackChildren(res))

==============================

PropositionalLogic.scala

verifies: 
  - match exhaustiveness for formulas in NNF 
  - stability of NNF
confirms:
  - NNF and implication-elimination do not commute
     Counter-example found and confirmed:
     f -> Implies(Implies(Literal(65), Literal(64)), Or(Literal(76), Literal(75)))
  - simplifying breaks NNF
     Counter-example found and confirmed:
     f -> Implies(Implies(Literal(31), Literal(30)), And(Literal(35), Literal(34)))

simplify                  match.      (14,42) valid               Z3        0.277
simplify                  postcond.           valid               Z3        2.006
isSimplified              match.      (22,45) valid               Z3        0.016
nnf                       match.      (30,49) valid               Z3        0.007
nnf                       postcond.           valid               Z3        5.184
isNNF                     match.      (42,38) valid               Z3        0.078
freeVars                  precond.    (54,37) valid               Z3        0.055
freeVars                  precond.    (54,54) valid               Z3        0.051
freeVars                  precond.    (55,36) valid               Z3        0.054
freeVars                  precond.    (55,53) valid               Z3        0.054
freeVars                  precond.    (56,41) valid               Z3        0.058
freeVars                  precond.    (56,58) valid               Z3        0.058
freeVars                  match.       (53,7) valid               Z3        0.065
fv                        precond.    (62,35) valid               Z3        0.051
wrongCommutative          postcond.           valid    induction  Z3        0.087
wrongCommutative          postcond.           valid    induction  Z3        0.088
wrongCommutative          postcond.           invalid  induction  Z3        0.317
wrongCommutative          postcond.           valid    induction  Z3        0.072
wrongCommutative          postcond.           unknown  induction                 
simplifyBreaksNNF         postcond.           valid    induction  Z3        0.247
simplifyBreaksNNF         postcond.           valid    induction  Z3        0.074
simplifyBreaksNNF         postcond.           invalid  induction  Z3        0.312
simplifyBreaksNNF         postcond.           valid    induction  Z3        0.056
simplifyBreaksNNF         postcond.           valid    induction  Z3        0.149
nnfIsStable               postcond.           valid    induction  Z3        0.077
nnfIsStable               postcond.           valid    induction  Z3        0.076
nnfIsStable               postcond.           valid    induction  Z3        0.076
nnfIsStable               postcond.           valid    induction  Z3        0.053
nnfIsStable               postcond.           valid    induction  Z3        0.073
simplifyIsStable          postcond.           valid    induction  Z3        0.079
simplifyIsStable          postcond.           valid    induction  Z3        0.078
simplifyIsStable          postcond.           valid    induction  Z3        0.078
simplifyIsStable          postcond.           valid    induction  Z3        0.055
simplifyIsStable          postcond.           valid    induction  Z3        0.068

* /* Wrong assumption that 'nnf' and 'simplify' commute */
* @induct
* def wrongCommutative(f: Formula) : Boolean = {
*   nnf(simplify(f)) == simplify(nnf(f))
* } holds

* /* Wrong assumption that 'simplify' preserves NNF */
* @induct
* def simplifyBreaksNNF(f: Formula) : Boolean = {
*   require(isNNF(f))
*   isNNF(simplify(f))
* } holds

* /* A formula in NNF is not modified by the NNF transformation */
* @induct
* def nnfIsStable(f: Formula) : Boolean = {
*   require(isNNF(f))
*   nnf(f) == f
* } holds

* /* A simplified formula is not modified by the simplifying transformation */
* @induct
* def simplifyIsStable(f: Formula) : Boolean = {
*   require(isSimplified(f))
*   simplify(f) == f
* } holds

  /* It is sufficient to consider negations of only literals in pattern
   * matching */
  def freeVars(f: Formula): Set[Int] = {
  require(isNNF(f))
    f match {
      case And(lhs, rhs) => freeVars(lhs) ++ freeVars(rhs)
      case Or(lhs, rhs) => freeVars(lhs) ++ freeVars(rhs)
      case Implies(lhs, rhs) => freeVars(lhs) ++ freeVars(rhs)
      case Not(Literal(i)) => Set[Int](i)
      case Literal(i) => Set[Int](i)
    }
  }

  /* The precondition for the call to 'freeVars' is respected */
  def fv(f : Formula) = { freeVars(nnf(f)) }
