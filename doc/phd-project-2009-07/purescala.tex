\section{A Purely Functional Subset of Scala}
This section describes \purescala, the specification language of our
verification system, as well as the programming language under consideration
in its first version. As mentioned previously, {\purescala} is purely
functional: computations have no side effects. All features, including the
concrete syntax, are taken from Scala or added as part of a minimalistic
library, and as a result, any valid {\purescala} program is a valid Scala
program as well\footnote{Provided the inclusion of our small library, that
is.}, and can be compiled and executed using {\tt scalac} and {\tt scala}.
When displaying code examples, for reasons of space and clarity, we sometimes
replace elements of the concrete syntax by shorter versions (printing $\neq$
instead of \K{!=}, for instance). It particular, since there are no assignments
in {\purescala}, we always print $=$ instead of \K{==}, with no risk of
confusion. All object-oriented features of Scala are kept out {\purescala}:
there are no classes (expect for case classes, but with the restrictions we
impose on them, they really just become immutable records).

\subsection{Features}
\subsubsection{Primitive Types}
The \K{Boolean} type is associated with the literals \K{true} and \K{false}
and the usual operators ($\neg$, $\land$, $\lor$, $=$, $\neq$). There is also
an additional binary operator $\rightarrow$ which we describe later. This
type is also used as the basic type for assertions and contracts.

The \K{Int} type represent 32-bit integers and comes with the standard set of
arithmetic operators and relation symbols ($+$, $-$, $\cdot$, $/$, $=$,
$\neq$, $<$, $\leq$, $>$, $\geq$). Integer constants can be written in any
format defined in the Scala specification.

\subsubsection{Collection Types}
The \K{Option[A]} parametric type represents collections of $0$ or $1$
element. Just like any other parametric type of {\purescala}, it can be
instantiated with any other {\purescala} type, but since there are no type
variables, it has to be made concrete. Values of types \K{Option[A]} are
constructed by using \K{Some(\ldots)} or \K{None}, with the semantics being
that all \K{None} values (of the same type) are equal, \K{None} is never
equal to a \K{Some} value, and \K{Some($v_1$)} equals \K{Some($v_2$)} if and
only if \K{$v_1$} and \K{$v_2$} are of the same type and are equal according
to the definition of equality on that type.

The \K{List[A]} type is used to represent linked lists. Although lists are
pointer-based data structures, the comparison of two lists is always done
element-by-element, and never on the references.

Sets are useful for abstracting the content of data structures and are
available in {\purescala} through the use of the (parametric) Scala library
class \K{scala.collection.immutable.Set} and its companion object. The expected
constructors, operators and relation symbols ($\emptyset$, $\{ \ldots \}$,
$\cup$, $\cap$, $\in$, $\subseteq$) are available in this class.

Multisets are not a part of the Scala library, but we consider them to be part
of {\purescala} for convenience. We have a concrete implementation of that
class so in practice,{\purescala} programs using multisets can be compiled by
importing the proper definition. The operations are similar to those on sets, with the addition of the multiplicity function and $\uplus$.

The parametric type \K{Map[A,B]} is used to represent functional maps. Like the
other data types, it is purely functional, so updating a map returns a new map.
The operations on maps are insertion, deletion and lookup. Lookup returns an
\K{Option} type.

\subsubsection{Algebraic Data Types}
An important feature of {\purescala} is the possibility to define recursive
data types. They correspond to case classes in Scala with the additional
restrictions that all class hierarchies should be sealed, that classes can not
declare methods or fields that are not arguments to the constructor, and that
they should not be type-parametric.

\subsubsection{Expressions}
An expression in {\purescala} is either a value of the types mentioned above
expressed a literal, or returned by a call to a constructor or a function call,
or the result of the evaluation of one of the two control-flow contructs;
if-then-else expressions and pattern matching. If-then-else expressions work as
in Scala, and the else branch is not optional. Pattern matching can be done on
integers, booleans, option types and user-defined recursive data types.
Patterns can be guarded by an additional boolean constraint.

\subsubsection{Structure of Programs}
For simplicity reasons, a {\purescala} program should be written entirely
within one component, or \K{object} in Scala terminology. All function, type,
and ``global'' value definitions therefore have the same lexical scope. An
exception to this rule is the possibility to write a \K{main} function, which
is ignored by the static analysis, yet useful for runtime evaluation.

\subsection{Specifications}
Specifications can be given in terms of pre- and post-conditions of functions,
but as mentioned in the introduction, this is not the most interesting form of
contracts for {\purescala}. We write global specifications by means of calls to
\K{assert} placed at the top-level of the main component. The special method \K{forAll} works as a universal quantifier on {\purescala} types. Its signature is the following:

\lstinputlisting{code/forall-method.scala.cute}

Its semantics are that \K{forAll[A](f: A $\Rightarrow$ Boolean)} is true if and
only if \K{f} returns true for any argument of type \K{A}. It should be clear that we can write a predicate with multiple universal quantifications using \K{forAll} repeatedly in a nested way, however this can lead to lengthy expressions, so we write these in a shorter way. For instance, we display the following universally quantified specification:

\lstinputlisting{code/spec-long.scala.cute}

\ldots as:

\lstinputlisting{code/spec-short.scala.cute}

It should be noted that these universally quantified assertions are strictly
more expressive that contracts expressed as pre- and post-conditions. Indeed,
consider a function \K{f($x_1$, \ldots, $x_n$)} with pre-condition \K{pre($x_1$,
\ldots, $x_n$)} and post-condition \K{res $\Rightarrow$ post(res, $x_1$, \ldots,
$x_n$)}, where \K{res} is a variable representing the result of the evaluation. Then the contracts can be rewritten as the universally quantified specification:

\begin{lstlisting}
$\forall$ $x_1$, ..., $x_n$ . 
  pre($x_1$, ..., $x_n$) $\rightarrow$ post(f($x_1$, ..., $x_n$), $x_1$, ..., $x_n$)
\end{lstlisting}

In contrast, pre- and post-conditions can not be used to reason about different
executions, for example to state that two different functions applied to the
same arguments always yield the same result.
