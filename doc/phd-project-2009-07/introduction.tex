\section{Introduction}
Static software analysis systems typically work on source code annotated with
specifications. The executable code is written in a programming language, and
the annotations in a specification language. It is desirable for the latter to
be easily comprehensible by the programmer, who, by definition, is an expert in
the former. The design decisions which govern these languages are different,
though: the programming language on the one hand, should allow the developer to
efficiently describe computational processes, that is the algorithmic
transformation of data. The specification language on the other hand should
serve the purpose of describing relationships between data, for instance the
relationship between a function arguments and its result, or between the
results of two functions applied to the same arguments. (In a purely functional
language, these two purposes become very close.) Additionally, the verification
conditions eventually generated by the system should be expressed in a
tractable logic, and that logic is closely tied to the choice of the
specification language.

Our long-term goal is the verification of programs written in the Scala
programming language \cite{scalalang}, annotated with specifications written in
a subset of Scala itself. Apart from the advantage that a user will be able to
write these specifications as easily as the rest of his code, a second
immediate benefit is that it will allow us to combine a test-based approach
with our static analyses, since such specifications are executable. Finally,
should both testing and static checking fail to convince a user that his
program is conforming to its stated properties, the specifications will always
be available for runtime checking, {\it \`a la} Eiffel. A natural choice for
our specification language is a purely functional subset of Scala, which we
call \purescala, and which we describe in the next section. As a first step in
our long-term project, we will use \purescala\ as both the specification
\emph{and} the programming language. That is, we will verify \purescala\
programs annotated with \purescala\ specifications.

This may appear to be a curious choice: indeed, if our specifications consisted
only in pre- and post- conditions, as in most verification
systems\footnote{Verification systems for object-oriented languages usually
also have a mechanism to express class invariants.}, the temptation would be
high for a programmer to always copy a function body in its post-condition, and
this would defeat the purpose of have specifications, which are supposed to
provide an abstraction mechanism for the computations taking place in the
functions. To give contracts additional expressive power, our system allows
universally quantified global specifications.

The rest of this report is as follows: the next section describes
{\purescala}, the third one an example of a proof in the system, then we
give an overview of the implementation status and describe future work.
