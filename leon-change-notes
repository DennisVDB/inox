In file ExprOps.scala, in function simplestValue:

SimplestValue(tpe: TypeTree) : Expr = tpe match {
    case Int32Type                  => IntLiteral(0)
    case IntegerType                => InfiniteIntegerLiteral(0)
    case CharType                   => CharLiteral('a')
    case BooleanType                => BooleanLiteral(false)
    case UnitType                   => UnitLiteral()
    case SetType(baseType)          => EmptySet(tpe)
    case MapType(fromType, toType)  => EmptyMap(fromType, toType)
    case TupleType(tpes)            => Tuple(tpes.map(simplestValue))
    case ArrayType(tpe)             => EmptyArray(tpe)   
    case RationalType               => RationalLiteral(0, 1)

In file Expressions.scala after UntilLiteral definition

 case class RationalLiteral(numerator: BigInt, denominator: BigInt) extends Literal[(BigInt,BigInt)] {
    val value = (numerator,denominator)
    val getType = RationalType
    
    override def toString =  {
      if(denominator == 1) numerator.toString
      else numerator + "/" + denominator
    }
  }
In file Expressions.scala, first five arithmetic types

/* Arithmetic */
  case class Plus(lhs: Expr, rhs: Expr) extends Expr {
    val getType = superNumericType(lhs.getType, rhs.getType)
  }
  
  case class Minus(lhs: Expr, rhs: Expr) extends Expr {
    val getType = superNumericType(lhs.getType, rhs.getType)
  }
  
  case class UMinus(expr: Expr) extends Expr {
    require(isNumericType(expr.getType))
    val getType = expr.getType
  }
  
  case class Times(lhs: Expr, rhs: Expr) extends Expr {
    val getType = superNumericType(lhs.getType, rhs.getType)
  }
  
  case class Division(lhs: Expr, rhs: Expr) extends Expr {    
    val getType = superNumericType(lhs.getType, rhs.getType)
  }  


In file PrettyPrinter.scala, in function pp

case Let(b,d,e) =>
        optB { d match {
          case _:LetDef | _ : Let | LetPattern(_,_,_) =>
            p"""|val $b = {
                |  $d
                |}
                |$e"""
          case _ =>
            p"""|val $b = $d;
                |$e"""
        }}

'b' is replaced by 'd'

In file PrettyPrinter.scala,  In function requireBraces (before the case that returns true)

    case (_, Some(_: IfExpr)) => false

In file Types.scala, 

import PrinterHelpers._

After the definition of "IntegerType"

  case object RationalType extends TypeTree with PrettyPrintable {
    def printWith(implicit pctx: PrinterContext) {
      p"Real"
    }
  }

  def isNumericType(t: TypeTree) = t match {
    case IntegerType | RationalType => true
    case _ => false
  }

  def superNumericType(t1: TypeTree, t2: TypeTree) = {
    require(isNumericType(t1) && isNumericType(t2))
    if (t1 == RationalType || t2 == RationalType) RationalType
    else IntegerType
  }

In AbstractZ3Solver, in function preparesorts 

Add the following after sorts += IntegerType -> ...
sorts += RationalType -> z3.mkRealSort

In function typeToSort 
add the first "case Int32Type | BooleanType | UnitType | IntegerType | CharType | RationalType"

In function "toZ3Formula"

After infiniteIntegerLiteral add 
      case RationalLiteral(num, denom) => z3.mkNumeral(s"${num.toString} / ${denom.toString}", typeToSort(RationalType))
In Lessthan, lessequals ...
case LessThan(l, r) => l.getType match {
        case RationalType => z3.mkLT(rec(l), rec(r))
        case IntegerType => z3.mkLT(rec(l), rec(r))
        case Int32Type => z3.mkBVSlt(rec(l), rec(r))
      }
      case LessEquals(l, r) => l.getType match {
        case RationalType => z3.mkLE(rec(l), rec(r))
        case IntegerType => z3.mkLE(rec(l), rec(r))
        case Int32Type => z3.mkBVSle(rec(l), rec(r))
      }
      case GreaterThan(l, r) => l.getType match {
        case RationalType => z3.mkGT(rec(l), rec(r))
        case IntegerType => z3.mkGT(rec(l), rec(r))
        case Int32Type => z3.mkBVSgt(rec(l), rec(r))
      }
      case GreaterEquals(l, r) => l.getType match {
        case RationalType => z3.mkGE(rec(l), rec(r))
        case IntegerType => z3.mkGE(rec(l), rec(r))
        case Int32Type => z3.mkBVSge(rec(l), rec(r))
      }

In function "fromZ3Formula"
in kind match , add after Z3NumeralIntAST

case Z3NumeralRealAST(num: BigInt, dem: BigInt) => {
          val rl = RationalLiteral(num, dem)
          rl
        }

In file Main.scala, add in list 'allPhases'
transformations.InstrumentationDriver,
      invariant.engine.InferInvariantsPhase)
ad the end

add after optEval
val optInstrument = LeonFlagOptionDef("instrument", "Instrument the code for inferring time/depth/stack bounds", false)
    val optInferInv = LeonFlagOptionDef("inferInv", "Infer invariants from (instrumented) the code", false)

after import MainComponent._
import invariant.engine.InferInvariantsPhase
    import transformations.InstrumentationDriver

Add  after evalF
val inferInvF = ctx.findOptionOrDefault(optInferInv)
    val instrumentF = ctx.findOptionOrDefault(optInstrument)

In pipe process add after else if(evalF) ...
        else if (inferInvF) InstrumentationDriver andThen InferInvariantsPhase
        else if (instrumentF) InstrumentationDriver
